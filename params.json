{"name":"Transistore","tagline":"Distributed data store for transient (temporary, time-bound) data. Based on ClusterMate/StoreMate","body":"# TransiStore\r\n\r\nTransiStore is a distributed data store for temporary (time-bound, possibly but not necessarily transient) data, such as intermediate processing results (for Map/Reduce, Hadoop), staging area between high-volume procuders and consumers (log processing and aggregation), or just as general-purpose store for data exchange.\r\n\r\nTransiStore is built on [ClusterMate](https://github.com/cowtowncoder/ClusterMate) platform, and serves as a sample system.\r\nNote that implementing storage system with different behavior, using `ClusterMate` (possibly using `TransiStore` as sample code) is highly encouraged: it is not meant as \"The\" storage system; although if it works as-is for your use case, all the better.\r\n\r\n## Basics\r\n\r\n### License\r\n\r\n'TransiStore` (and all its dependencies) are licensed under [Apache 2.0](http://www.apache.org/licenses/LICENSE-2.0.html).\r\n\r\n### Functionality\r\n\r\n`TransiStore` can be viewed as a distributed key/value (\"BLOB\") store which explicitly supports Key Range queries for primary keys.\r\nStored entries have explicit time-to-live setting and service removes expired entries if they have not been explicitly deleted earlier.\r\nClusters are horizontally scalable and allow addition/removal of storage nodes, without restarting other nodes.\r\n\r\nThe main limitation -- as of now, at least -- is that content is Write-Once; that is, entries are immutable after being added: they may however. be explicitly deleted (and if not, will expire as per time-to-live settings). While this is a limit that use cases must conform to, it greatly simplifies implementation and improves handling performance, as conflict resolution is simple to handle (due to minimal number of cases to resolve).\r\n\r\n### Underlying (per-node) storage\r\n\r\nStorage layer comes from [ClusterMate](https://github.com/cowtowncoder/ClusterMate) (which in turn builds on [StoreMate](https://github.com/cowtowncoder/StoreMate) project.\r\n\r\nHere are some highlights (for more refer to `StoreMate` project) of storage system:\r\n\r\n* Pluggable backends: default implementation uses `BDB-JE` for local storage, but there is also experimental `LevelDB` backend.\r\n* Automatic on-the-fly (de)compression; negotiated using standard HTTP; supports multiple compression methods (client can pre-compress instead of server, or defer uncompression)\r\n* Partial content queries (HTTP Range supported)\r\n* Key-range queries.\r\n\r\nand additional features that `ClusterMate` provides are:\r\n\r\n* Peer-to-peer content synchronization used for on-going content synchronization, recovery, and bootstrapping of newly added nodes\r\n* Configurable redundance (number of copies to store), with different client-controlled minimal required writes.\r\n* Client-configurable data expiration rates (per-entry time-to-live) to ensure that content will not live forever even if no explicit deletions are performed\r\n* Key partitioning to support cluster-wide key-range queries (routing by partition; queries within single partition) -- note: key structure fully configurable at `ClusterMate` level; TransiStore uses a simple `partition + path` key structure.\r\n\r\n### Configuration\r\n\r\nConfiguration is simple: it consists of a single JSON configuration file. Sample configuration\r\nfiles can be found from under `sample/`.\r\n\r\n## Why not X?\r\n\r\n(where X may be \"HBase\", \"Cassandra\", \"Voldemort\", \"Riak\" or any of dozens of distributed key/value stores)\r\n\r\nFeatures that separate TransiStore for most other \"noSQL\" key/value stores are ones listed earlier:\r\n\r\n1. Can store LARGE entries (similar to S3): authors use it for storing 10 megabyte sized entries. It is designed for such usage -- you can even do partial GETs (with HTTP Range header)\r\n2. Key-range queries: some noSQL systems (like HBase) support them, but most don't (Cassandra, Voldemort), at least with recommended set ups. TransiStore is designed to  fully support them.\r\n3. Automatic expiration of data: useful for intermediate results (Hadoop processing? Log aggregation?), weekly reports, or even some types of caching. You just specify maximum life-time for entries and system purges them as necessary\r\n4. Simple configuration: single configuration file, used for all nodes; and even clients if you want.\r\n5. Automatic node recovery: once a node has its configuration file, it is ready to start up and synchronize entries it needs -- no manual process or delicate coordination needed (NOTE: there will be need to build dashboards, tools to help track progress -- but foundational functionality works for actual syncing)\r\n\r\nThere are many more advanced features; but most of them are common within this class of servers\r\n(recovery, configurable number of copies required, statistics/metrics).\r\n\r\n## Documentation\r\n\r\nHere are things you will probably want to read first:\r\n\r\n* [Installing](../../wiki/Install) (my first TransiStore cluster): Build or download jar, find a config, start up!\r\n* [Configuration](../../wiki/Configuration): what do those sample configs contain?\r\n* [Tools](../../wiki/Tools): Yes, we have small set of command-line tools too; accessed with `tstore.sh` wrapper (invoking `ts-client` jar)\r\n\r\nand here's some more stuff:\r\n\r\n* [Dependencies](../../wiki/Dependencies) -- what is TransiStore built of?\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}